diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 80842b8f4..f76ed3e69 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -3110,6 +3110,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			conf->hw_mode = HOSTAPD_MODE_IEEE80211G;
 		else if (os_strcmp(pos, "ad") == 0)
 			conf->hw_mode = HOSTAPD_MODE_IEEE80211AD;
+		else if (os_strcmp(pos, "ah") == 0)
+			conf->hw_mode = HOSTAPD_MODE_IEEE80211AH;        
 		else if (os_strcmp(pos, "any") == 0)
 			conf->hw_mode = HOSTAPD_MODE_IEEE80211ANY;
 		else {
diff --git a/src/ap/hw_features.c b/src/ap/hw_features.c
index 7849be181..4b87fcd9c 100644
--- a/src/ap/hw_features.c
+++ b/src/ap/hw_features.c
@@ -152,6 +152,7 @@ int hostapd_prepare_rates(struct hostapd_iface *iface,
 	int basic_rates_a[] = { 60, 120, 240, -1 };
 	int basic_rates_b[] = { 10, 20, -1 };
 	int basic_rates_g[] = { 10, 20, 55, 110, -1 };
+    int basic_rates_ah[] = { 10, 20, 40,  80, 160 -1 };
 	int *basic_rates;
 
 	if (iface->conf->basic_rates)
@@ -166,6 +167,9 @@ int hostapd_prepare_rates(struct hostapd_iface *iface,
 	case HOSTAPD_MODE_IEEE80211G:
 		basic_rates = basic_rates_g;
 		break;
+    case HOSTAPD_MODE_IEEE80211AH:
+        basic_rates = basic_rates_ah;
+		break;
 	case HOSTAPD_MODE_IEEE80211AD:
 		return 0; /* No basic rates for 11ad */
 	default:
@@ -1148,6 +1152,8 @@ const char * hostapd_hw_mode_txt(int mode)
 		return "IEEE 802.11g";
 	case HOSTAPD_MODE_IEEE80211AD:
 		return "IEEE 802.11ad";
+	case HOSTAPD_MODE_IEEE80211AH:
+		return "IEEE 802.11ah";        
 	default:
 		return "UNKNOWN";
 	}
diff --git a/src/common/defs.h b/src/common/defs.h
index f43bdb5d1..584535e56 100644
--- a/src/common/defs.h
+++ b/src/common/defs.h
@@ -355,6 +355,7 @@ enum hostapd_hw_mode {
 	HOSTAPD_MODE_IEEE80211G,
 	HOSTAPD_MODE_IEEE80211A,
 	HOSTAPD_MODE_IEEE80211AD,
+    HOSTAPD_MODE_IEEE80211AH,
 	HOSTAPD_MODE_IEEE80211ANY,
 	NUM_HOSTAPD_MODES
 };
@@ -420,6 +421,11 @@ enum eap_proxy_sim_state {
 /* enum chan_width - Channel width definitions */
 enum chan_width {
 	CHAN_WIDTH_20_NOHT,
+    CHAN_WIDTH_1,
+    CHAN_WIDTH_2,
+    CHAN_WIDTH_4,
+    CHAN_WIDTH_8,
+    CHAN_WIDTH_16,
 	CHAN_WIDTH_20,
 	CHAN_WIDTH_40,
 	CHAN_WIDTH_80,
diff --git a/src/common/hw_features_common.c b/src/common/hw_features_common.c
index b8b886fa1..3112dd0cb 100644
--- a/src/common/hw_features_common.c
+++ b/src/common/hw_features_common.c
@@ -770,6 +770,21 @@ int chan_bw_allowed(const struct hostapd_channel_data *chan, u32 bw,
 	u32 bw_mask;
 
 	switch (bw) {
+	case 1:
+		bw_mask = HOSTAPD_CHAN_WIDTH_1;
+		break;
+	case 2:
+		bw_mask = HOSTAPD_CHAN_WIDTH_2;
+		break;
+	case 4:
+		bw_mask = HOSTAPD_CHAN_WIDTH_4;
+		break;
+	case 8:
+		bw_mask = HOSTAPD_CHAN_WIDTH_8;
+		break;
+	case 16:
+		bw_mask = HOSTAPD_CHAN_WIDTH_16;
+		break;        
 	case 20:
 		bw_mask = HOSTAPD_CHAN_WIDTH_20;
 		break;
diff --git a/src/common/ieee802_11_common.c b/src/common/ieee802_11_common.c
index ec174562a..86a368f6c 100644
--- a/src/common/ieee802_11_common.c
+++ b/src/common/ieee802_11_common.c
@@ -899,6 +899,13 @@ enum hostapd_hw_mode ieee80211_freq_to_channel_ext(unsigned int freq,
 	if (sec_channel > 1 || sec_channel < -1)
 		return NUM_HOSTAPD_MODES;
 
+    /* 802.11ah */
+    if (freq <= 1000) {
+            *channel = freq;
+            *op_class = 0;
+            return HOSTAPD_MODE_IEEE80211AH;
+    }
+    
 	if (freq >= 2412 && freq <= 2472) {
 		if ((freq - 2407) % 5)
 			return NUM_HOSTAPD_MODES;
@@ -1123,6 +1130,11 @@ int ieee80211_chaninfo_to_channel(unsigned int freq, enum chan_width chanwidth,
 
 	switch (chanwidth) {
 	case CHAN_WIDTH_UNKNOWN:
+    case CHAN_WIDTH_1:
+    case CHAN_WIDTH_2:
+    case CHAN_WIDTH_4:
+    case CHAN_WIDTH_8:
+    case CHAN_WIDTH_16:
 	case CHAN_WIDTH_20_NOHT:
 	case CHAN_WIDTH_20:
 	case CHAN_WIDTH_40:
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 5b2c71ca0..d58f7decb 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -60,12 +60,17 @@
 
 /* Allowed bandwidth mask */
 enum hostapd_chan_width_attr {
-	HOSTAPD_CHAN_WIDTH_10   = BIT(0),
-	HOSTAPD_CHAN_WIDTH_20   = BIT(1),
-	HOSTAPD_CHAN_WIDTH_40P  = BIT(2),
-	HOSTAPD_CHAN_WIDTH_40M  = BIT(3),
-	HOSTAPD_CHAN_WIDTH_80   = BIT(4),
-	HOSTAPD_CHAN_WIDTH_160  = BIT(5),
+    HOSTAPD_CHAN_WIDTH_1    = BIT(0),
+    HOSTAPD_CHAN_WIDTH_2    = BIT(1),
+    HOSTAPD_CHAN_WIDTH_4    = BIT(2),
+    HOSTAPD_CHAN_WIDTH_8    = BIT(3),
+    HOSTAPD_CHAN_WIDTH_16   = BIT(4),
+	HOSTAPD_CHAN_WIDTH_10   = BIT(5),
+	HOSTAPD_CHAN_WIDTH_20   = BIT(6),
+	HOSTAPD_CHAN_WIDTH_40P  = BIT(7),
+	HOSTAPD_CHAN_WIDTH_40M  = BIT(8),
+	HOSTAPD_CHAN_WIDTH_80   = BIT(9),
+	HOSTAPD_CHAN_WIDTH_160  = BIT(10),
 };
 
 /* Filter gratuitous ARP */
diff --git a/src/drivers/driver_common.c b/src/drivers/driver_common.c
index a7ebe9566..92b04b999 100644
--- a/src/drivers/driver_common.c
+++ b/src/drivers/driver_common.c
@@ -100,6 +100,16 @@ const char * event_to_string(enum wpa_event_type event)
 const char * channel_width_to_string(enum chan_width width)
 {
 	switch (width) {
+	case CHAN_WIDTH_1:
+		return "1 MHz";
+	case CHAN_WIDTH_2:
+		return "2 MHz";
+	case CHAN_WIDTH_4:
+		return "4 MHz";
+	case CHAN_WIDTH_8:
+		return "8 MHz";
+	case CHAN_WIDTH_16:
+		return "16 MHz";        
 	case CHAN_WIDTH_20_NOHT:
 		return "20 MHz (no HT)";
 	case CHAN_WIDTH_20:
@@ -121,6 +131,16 @@ const char * channel_width_to_string(enum chan_width width)
 int channel_width_to_int(enum chan_width width)
 {
 	switch (width) {
+	case CHAN_WIDTH_1:
+		return 1;
+	case CHAN_WIDTH_2:
+		return 2;
+	case CHAN_WIDTH_4:
+		return 4;
+	case CHAN_WIDTH_8:
+		return 8;
+	case CHAN_WIDTH_16:
+		return 16;        
 	case CHAN_WIDTH_20_NOHT:
 	case CHAN_WIDTH_20:
 		return 20;
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 54adae44b..036d25988 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -203,6 +203,16 @@ static int i802_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
 enum chan_width convert2width(int width)
 {
 	switch (width) {
+	case NL80211_CHAN_WIDTH_1:
+		return CHAN_WIDTH_1;
+	case NL80211_CHAN_WIDTH_2:
+		return CHAN_WIDTH_2;
+	case NL80211_CHAN_WIDTH_4:
+		return CHAN_WIDTH_4;
+	case NL80211_CHAN_WIDTH_8:
+		return CHAN_WIDTH_8;
+	case NL80211_CHAN_WIDTH_16:
+		return CHAN_WIDTH_16;        
 	case NL80211_CHAN_WIDTH_20_NOHT:
 		return CHAN_WIDTH_20_NOHT;
 	case NL80211_CHAN_WIDTH_20:
@@ -4840,6 +4850,21 @@ static int nl80211_put_freq_params(struct nl_msg *msg,
 
 		wpa_printf(MSG_DEBUG, "  * bandwidth=%d", freq->bandwidth);
 		switch (freq->bandwidth) {
+		case 1:
+			cw = NL80211_CHAN_WIDTH_1;
+			break;
+		case 2:
+			cw = NL80211_CHAN_WIDTH_2;
+			break;
+		case 4:
+			cw = NL80211_CHAN_WIDTH_4;
+			break;
+		case 8:
+			cw = NL80211_CHAN_WIDTH_8;
+			break;
+		case 16:
+			cw = NL80211_CHAN_WIDTH_16;
+			break;
 		case 20:
 			cw = NL80211_CHAN_WIDTH_20;
 			break;
diff --git a/src/drivers/driver_nl80211_capa.c b/src/drivers/driver_nl80211_capa.c
index d3d43d48a..148337d10 100644
--- a/src/drivers/driver_nl80211_capa.c
+++ b/src/drivers/driver_nl80211_capa.c
@@ -1984,7 +1984,10 @@ wpa_driver_nl80211_postprocess_modes(struct hostapd_hw_modes *modes,
 	for (m = 0; m < *num_modes; m++) {
 		if (!modes[m].num_channels)
 			continue;
-		if (modes[m].channels[0].freq < 2000) {
+        if (modes[m].channels[0].freq < 1000) {
+            modes[m].mode = HOSTAPD_MODE_IEEE80211AH;
+        }
+		else if (modes[m].channels[0].freq < 2000) {
 			modes[m].num_channels = 0;
 			continue;
 		} else if (modes[m].channels[0].freq < 4000) {
@@ -2127,8 +2130,14 @@ static void nl80211_reg_rule_max_eirp(u32 start, u32 end, u32 max_eirp,
 		for (c = 0; c < mode->num_channels; c++) {
 			struct hostapd_channel_data *chan = &mode->channels[c];
 			if ((u32) chan->freq - 10 >= start &&
-			    (u32) chan->freq + 10 <= end)
+			    (u32) chan->freq + 10 <= end && 
+                chan->freq >= 1000)
 				chan->max_tx_power = max_eirp;
+            // 802.11ah sub-1GHz
+            else if ((u32) chan->freq >= start &&
+			    (u32) chan->freq + 1 <= end &&
+			    chan->freq < 1000)
+                chan->max_tx_power = max_eirp;
 		}
 	}
 }
@@ -2409,6 +2418,8 @@ static const char * modestr(enum hostapd_hw_mode mode)
 		return "802.11a";
 	case HOSTAPD_MODE_IEEE80211AD:
 		return "802.11ad";
+	case HOSTAPD_MODE_IEEE80211AH:
+		return "802.11ah";
 	default:
 		return "?";
 	}
diff --git a/src/drivers/driver_nl80211_event.c b/src/drivers/driver_nl80211_event.c
index c6f3e0ef6..a54201d5c 100644
--- a/src/drivers/driver_nl80211_event.c
+++ b/src/drivers/driver_nl80211_event.c
@@ -626,6 +626,11 @@ static int calculate_chan_offset(int width, int freq, int cf1, int cf2)
 	int freq1 = 0;
 
 	switch (convert2width(width)) {
+	case CHAN_WIDTH_1:
+	case CHAN_WIDTH_2:
+	case CHAN_WIDTH_4:
+	case CHAN_WIDTH_8:
+	case CHAN_WIDTH_16:        
 	case CHAN_WIDTH_20_NOHT:
 	case CHAN_WIDTH_20:
 		return 0;
@@ -2739,6 +2744,21 @@ static void nl80211_sta_opmode_change_event(struct wpa_driver_nl80211_data *drv,
 		case NL80211_CHAN_WIDTH_20_NOHT:
 			ed.sta_opmode.chan_width = CHAN_WIDTH_20_NOHT;
 			break;
+		case NL80211_CHAN_WIDTH_1:
+			ed.sta_opmode.chan_width = CHAN_WIDTH_1;
+            break;
+		case NL80211_CHAN_WIDTH_2:
+			ed.sta_opmode.chan_width = CHAN_WIDTH_2;
+            break;
+		case NL80211_CHAN_WIDTH_4:
+			ed.sta_opmode.chan_width = CHAN_WIDTH_4;
+            break;
+		case NL80211_CHAN_WIDTH_8:
+			ed.sta_opmode.chan_width = CHAN_WIDTH_8;
+            break;
+		case NL80211_CHAN_WIDTH_16:
+			ed.sta_opmode.chan_width = CHAN_WIDTH_16;
+            break;
 		case NL80211_CHAN_WIDTH_20:
 			ed.sta_opmode.chan_width = CHAN_WIDTH_20;
 			break;
diff --git a/wpa_supplicant/events.c b/wpa_supplicant/events.c
index 5e73ab406..37e60886d 100644
--- a/wpa_supplicant/events.c
+++ b/wpa_supplicant/events.c
@@ -836,6 +836,11 @@ static int rate_match(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid,
 	if (mode == NULL)
 		return 0;
 
+	// don't handle 802.11ah yet
+    if(mode->mode == HOSTAPD_MODE_IEEE80211AH) {
+        return 1;
+    }
+    
 	for (i = 0; i < (int) sizeof(scan_ie); i++) {
 		rate_ie = wpa_bss_get_ie(bss, scan_ie[i]);
 		if (rate_ie == NULL)
