diff --git a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-build-config.h b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-build-config.h
index a377e47..b5d99b2 100755
--- a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-build-config.h
+++ b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-build-config.h
@@ -19,7 +19,6 @@
 
 #include <linux/version.h>
 
-#define NRC_BUILD_USE_HWSCAN
 /* #define CONFIG_NRC_HIF_PRINT_BEACON */
 /* #define CONFIG_NRC_HIF_PRINT_RX_AUTH */
 /* #define CONFIG_NRC_HIF_PRINT_RX_DATA */
@@ -43,6 +42,15 @@
  * #define NRC_TARGET_KERNEL_VERSION KERNEL_VERSION(4, 4, 1)
  */
 #define NRC_TARGET_KERNEL_VERSION LINUX_VERSION_CODE
+#if KERNEL_VERSION(5, 10, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_S1G_CHANNEL 1
+#endif
+
+#ifdef CONFIG_S1G_CHANNEL
+#undef NRC_BUILD_USE_HWSCAN
+#else
+#define NRC_BUILD_USE_HWSCAN
+#endif
 
 #if KERNEL_VERSION(4, 10, 0) <= NRC_TARGET_KERNEL_VERSION
 #define GENL_ID_GENERATE 0
diff --git a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-debug.h b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-debug.h
index bb3df80..416941c 100755
--- a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-debug.h
+++ b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-debug.h
@@ -33,7 +33,7 @@ enum NRC_DEBUG_MASK {
 };
 #define NRC_DBG_MASK_ANY   (0xFFFFFFFF)
 
-/*#define DEFAULT_NRC_DBG_MASK (NRC_DBG_MASK_ANY)*/
+// #define DEFAULT_NRC_DBG_MASK (NRC_DBG_MASK_ANY)
 #define DEFAULT_NRC_DBG_MASK (BIT(NRC_DBG_PS) | BIT(NRC_DBG_STATE))
 
 extern unsigned long nrc_debug_mask;
diff --git a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-mac80211.c b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-mac80211.c
index 07f4a9e..97f9d1a 100755
--- a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-mac80211.c
+++ b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-mac80211.c
@@ -52,7 +52,7 @@
 	.center_freq = (_freq),				\
 	.hw_value = (_freq),				\
 	.max_power = 20,					\
-	.center_freq_fractional = (_freq_partial) \
+	.freq_offset = (_freq_partial) \
 }
 
 #define CHAN2G(freq)			\
@@ -81,53 +81,41 @@
 #define FREQ_TO_100KHZ(mhz, khz) (mhz * 10 + khz / 100)
 
 #if defined(CONFIG_S1G_CHANNEL)
-static struct ieee80211_channel nrc_channels_s1ghz[] = {
-	CHANS1G(902, 500),  /* Channel 1 */
-	CHANS1G(903, 0),    /* Channel 2 */
-	CHANS1G(903, 500),  /* Channel 3 */
-	CHANS1G(904, 500),  /* Channel 5 */
-	CHANS1G(905, 0),    /* Channel 6 */
-	CHANS1G(905, 500),  /* Channel 7 */
-	CHANS1G(906, 0),    /* Channel 8 */
-	CHANS1G(906, 500),  /* Channel 9 */
-	CHANS1G(907, 0),    /* Channel 10 */
-	CHANS1G(907, 500),  /* Channel 11 */
-	CHANS1G(908, 500),  /* Channel 13 */
-	CHANS1G(909, 0),    /* Channel 14 */
-	CHANS1G(909, 500),  /* Channel 15 */
-	CHANS1G(910, 0),    /* Channel 16 */
-	CHANS1G(910, 500),  /* Channel 17 */
-	CHANS1G(911, 0),    /* Channel 18 */
-	CHANS1G(911, 500),  /* Channel 19 */
-	CHANS1G(912, 500),  /* Channel 21 */
-	CHANS1G(913, 0),    /* Channel 22 */
-	CHANS1G(913, 500),  /* Channel 23 */
-	CHANS1G(914, 0),    /* Channel 24 */
-	CHANS1G(914, 500),  /* Channel 25 */
-	CHANS1G(915, 0),    /* Channel 26 */
-	CHANS1G(915, 500),  /* Channel 27 */
-	CHANS1G(916, 500),  /* Channel 29 */
-	CHANS1G(917, 0),    /* Channel 30 */
-	CHANS1G(917, 500),  /* Channel 31 */
-	CHANS1G(918, 0),    /* Channel 32 */
-	CHANS1G(918, 500),  /* Channel 33 */
-	CHANS1G(919, 0),    /* Channel 34 */
-	CHANS1G(919, 500),  /* Channel 35 */
-	CHANS1G(920, 500),  /* Channel 37 */
-	CHANS1G(921, 0),    /* Channel 38 */
-	CHANS1G(921, 500),  /* Channel 39 */
-	CHANS1G(922, 0),    /* Channel 40 */
-	CHANS1G(922, 500),  /* Channel 41 */
-	CHANS1G(923, 0),    /* Channel 42 */
-	CHANS1G(923, 500),  /* Channel 43 */
-	CHANS1G(924, 500),  /* Channel 45 */
-	CHANS1G(925, 0),    /* Channel 46 */
-	CHANS1G(925, 500),  /* Channel 47 */
-	CHANS1G(926, 0),    /* Channel 48 */
-	CHANS1G(926, 500),  /* Channel 49 */
-	CHANS1G(927, 0),    /* Channel 46 */
-	CHANS1G(927, 500),  /* Channel 51 */
+
+    static const struct ieee80211_sta_s1g_cap nrc_s1g_cap = {
+	.s1g = true,
+	.cap = { S1G_CAP0_SGI_1MHZ | S1G_CAP0_SGI_2MHZ | S1G_CAP0_SGI_4MHZ, // | S1G_CAP0_SGI_8MHZ | S1G_CAP0_SGI_16MHZ,
+		 0,
+		 0,
+		 S1G_CAP3_MAX_MPDU_LEN,
+		 0,
+		 S1G_CAP5_AMPDU,
+		 0,
+		 S1G_CAP7_DUP_1MHZ,
+		 S1G_CAP8_TWT_RESPOND | S1G_CAP8_TWT_REQUEST,
+		 0},
+	.nss_mcs = { 0xfc | 1, /* MCS 7 for 1 SS */
+	/* RX Highest Supported Long GI Data Rate 0:7 */
+		     0,
+	/* RX Highest Supported Long GI Data Rate 0:7 */
+	/* TX S1G MCS Map 0:6 */
+		     0xfa,
+	/* TX S1G MCS Map :7 */
+	/* TX Highest Supported Long GI Data Rate 0:6 */
+		     0x80,
+	/* TX Highest Supported Long GI Data Rate 7:8 */
+	/* Rx Single spatial stream and S1G-MCS Map for 1MHz */
+	/* Tx Single spatial stream and S1G-MCS Map for 1MHz */
+		     0 },
 };
+
+#define  MAX_NUM_S1G_CHAN 51
+
+#define  NUM_S1G_CHAN_US  51
+#define  S1G_CHAN_BASE_US 902000
+#define  S1G_CHAN_2MHZ_BASE_US 902000
+
+static struct ieee80211_channel nrc_channels_s1ghz[MAX_NUM_S1G_CHAN];
 #else
 static struct ieee80211_channel nrc_channels_2ghz[] = {
 	CHAN2G(2412), /* Channel 1 */
@@ -189,7 +177,7 @@ static struct ieee80211_channel nrc_channels_5ghz[] = {
 };
 #endif /* CONFIG_S1G_CHANNEL */
 
-
+#if !defined(CONFIG_S1G_CHANNEL)
 static struct ieee80211_rate nrc_rates[] = {
 	/* 11b rates */
 	{ .bitrate = 10 },
@@ -209,8 +197,19 @@ static struct ieee80211_rate nrc_rates[] = {
 	{ .bitrate = 480 },
 	{ .bitrate = 540 }
 };
+#else
+static struct ieee80211_rate nrc_rates[] = {
+	/* 11ah rates */
+	{ .bitrate = 10 },
+    { .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+    { .bitrate = 40, .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+//     { .bitrate = 80, .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+//     { .bitrate = 160, .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+};
+#endif
 
-#if defined(CONFIG_S1G_CHANNEL)
+#ifdef CONFIG_CUSTOM_REGDB
+#ifdef CONFIG_S1G_CHANNEL
 static const struct ieee80211_regdomain mac80211_regdom = {
 	.n_reg_rules = 1,
 	.alpha2 =  "99",
@@ -230,6 +229,7 @@ static const struct ieee80211_regdomain mac80211_regdom = {
 	},
 };
 #endif /* CONFIG_S1G_CHANNEL */
+#endif /* CONFIG_CUSTOM_REGDB */
 
 static const char nrc_gstrings_stats[][ETH_GSTRING_LEN] = {
 	"tx_pkts_nic",
@@ -855,8 +855,7 @@ static void nrc_mac_roc_finish(struct work_struct *work)
 {
 	struct nrc *nw = container_of(work, struct nrc, roc_finish.work);
 
-	nrc_mac_dbg("%s", __func__);
-	ieee80211_remain_on_channel_expired(nw->hw);
+    ieee80211_remain_on_channel_expired(nw->hw);
 }
 
 #ifdef CONFIG_USE_SCAN_TIMEOUT
@@ -1025,7 +1024,7 @@ get_wim_channel_width(enum nl80211_chan_width width)
 	case NL80211_CHAN_WIDTH_5:
 		return CH_WIDTH_5;
 	case NL80211_CHAN_WIDTH_10:
-		return CH_WIDTH_10;
+		return CH_WIDTH_10;      
 #if defined(CONFIG_S1G_CHANNEL)
 	case NL80211_CHAN_WIDTH_1:
 		return CH_WIDTH_1;
@@ -1037,11 +1036,52 @@ get_wim_channel_width(enum nl80211_chan_width width)
 		return CH_WIDTH_8;
 	case NL80211_CHAN_WIDTH_16:
 		return CH_WIDTH_16;
-#endif /* CONFIG_S1G_CHANNEL */
+	default:
+		return CH_WIDTH_1;
+#else
 	default:
 		return CH_WIDTH_20;
+#endif /* CONFIG_S1G_CHANNEL */
+	}
+}
+
+#ifdef CONFIG_S1G_CHANNEL
+
+// NOTE: support US only for now
+static void init_s1g_channels(struct ieee80211_channel *channels)
+{
+	int ch, freq;
+
+	for (ch = 0; ch < NUM_S1G_CHAN_US; ch++) {
+		
+        freq = S1G_CHAN_BASE_US + (ch + 1) * 500;
+		channels[ch].band = NL80211_BAND_S1GHZ;
+		channels[ch].center_freq = KHZ_TO_MHZ(freq);
+		channels[ch].freq_offset = freq % 1000;
+        
+        if(channels[ch].freq_offset > 0) {
+            channels[ch].flags = IEEE80211_CHAN_1MHZ;
+        }
+        else if (freq >= 9050 && (freq - 9000) % 2) {
+            channels[ch].flags = IEEE80211_CHAN_1MHZ | IEEE80211_CHAN_2MHZ;
+        }
+        else {
+            channels[ch].flags = IEEE80211_CHAN_1MHZ | IEEE80211_CHAN_2MHZ | IEEE80211_CHAN_4MHZ;
+        }
+		channels[ch].hw_value =  ch + 1;
+        
+        nrc_mac_dbg("%s: channels[%d].band %d channels[%d].center_freq %d channels[%d].freq_offset %d channels[%d].flags 0x%X channels[%d].hw_value %d freq %d\n", 
+                    __func__,
+                    ch, channels[ch].band,
+                    ch, channels[ch].center_freq,
+                    ch, channels[ch].freq_offset,
+                    ch, channels[ch].flags, 
+                    ch, channels[ch].hw_value,
+                    freq
+                   );
 	}
 }
+#endif
 
 #ifdef CONFIG_SUPPORT_CHANNEL_INFO
 static void nrc_mac_add_tlv_channel(struct sk_buff *skb,
@@ -1060,18 +1100,29 @@ static void nrc_mac_add_tlv_channel(struct sk_buff *skb,
 	ch_param.channel = chandef->chan->center_freq;
 	ch_param.type = ch_type;
 	ch_param.width = get_wim_channel_width(chandef->width);
+    
+    nrc_mac_dbg("%s: ch_param.channel(%d), ch_param.type(%d), ch_param.width(%d)\n", __func__, ch_param.channel,
+			ch_param.type, ch_param.width);
+    
 	nrc_wim_skb_add_tlv(skb, WIM_TLV_CHANNEL,
 				   sizeof(ch_param), &ch_param);
 #else
 	struct wim_s1g_channel_param param;
 
 	param.pr_freq = FREQ_TO_100KHZ(chandef->chan->center_freq,
-				chandef->chan->center_freq_fractional);
+				chandef->chan->freq_offset);
 	param.op_freq = FREQ_TO_100KHZ(chandef->center_freq1,
-				chandef->center_freq1_fractional);
-	param.width = get_wim_channel_width(chandef->width);
-	pr_err("nrc: pri(%d), op(%d), width(%d)\n", param.pr_freq,
-			param.op_freq, param.width);
+				chandef->freq1_offset);
+    
+    param.width = get_wim_channel_width(chandef->width);
+        
+    if(chandef->chan->freq_offset == 500)
+        param.width = CH_WIDTH_1;
+    else
+        param.width = CH_WIDTH_2;
+    
+    param.flags = 0;
+    
 	nrc_wim_skb_add_tlv(skb, WIM_TLV_S1G_CHANNEL, sizeof(param),
 			&param);
 #endif
@@ -1101,7 +1152,7 @@ static int nrc_mac_config(struct ieee80211_hw *hw, u32 changed)
 	int ret = 0;
 	struct sk_buff *skb;
 	bool ps_enable = false;
-
+    
 	skb = nrc_wim_alloc_skb(nw, WIM_CMD_SET, WIM_MAX_SIZE);
 
 	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
@@ -1109,15 +1160,11 @@ static int nrc_mac_config(struct ieee80211_hw *hw, u32 changed)
 #ifdef CONFIG_SUPPORT_CHANNEL_INFO
 		nw->band = hw->conf.chandef.chan->band;
 		nw->center_freq = hw->conf.chandef.chan->center_freq;
+		nrc_mac_add_tlv_channel(skb, &hw->conf.chandef);
 #else
 		nw->band = hw->conf.channel->band;
 		nw->center_freq = hw->conf.channel->center_freq;
-#endif
-
-#ifdef CONFIG_SUPPORT_CHANNEL_INFO
-		nrc_mac_add_tlv_channel(skb, &hw->conf.chandef);
-#else
-		nrc_mac_add_tlv_channel(skb, &hw->conf);
+        nrc_mac_add_tlv_channel(skb, &hw->conf);
 #endif
 		/* TODO: band (2G, 5G, etc) and bandwidth (20MHz, 40MHz, etc) */
 	}
@@ -1229,7 +1276,7 @@ static void nrc_mac_bss_info_changed(struct ieee80211_hw *hw,
 		nrc_wim_skb_add_tlv(skb, WIM_TLV_BASIC_RATE,
 				sizeof(info->basic_rates), &info->basic_rates);
 	}
-
+#ifndef CONFIG_S1G_CHANNEL
 	if (changed & BSS_CHANGED_HT) {
 		nrc_mac_dbg("ht: %08x", info->ht_operation_mode);
 
@@ -1237,7 +1284,7 @@ static void nrc_mac_bss_info_changed(struct ieee80211_hw *hw,
 				    sizeof(info->ht_operation_mode),
 				    &info->ht_operation_mode);
 	}
-
+#endif
 	if (changed & BSS_CHANGED_BSSID) {
 		nrc_mac_dbg("bssid=%pM", info->bssid);
 
@@ -1579,11 +1626,9 @@ static int nrc_mac_get_survey(struct ieee80211_hw *hw, int idx,
 {
 	struct ieee80211_conf *conf = &hw->conf;
 
-	nrc_mac_dbg("%s (idx=%d)", __func__, idx);
-
 	if (idx != 0)
 		return -ENOENT;
-
+    
 	/* Current channel */
 #ifdef CONFIG_SUPPORT_CHANNEL_INFO
 	survey->channel = conf->chandef.chan;
@@ -1599,8 +1644,8 @@ static int nrc_mac_get_survey(struct ieee80211_hw *hw, int idx,
 	 * report any noise, especially not a magically conjured one :-)
 	 */
 	survey->filled = SURVEY_INFO_NOISE_DBM;
-	survey->noise = -92;
-
+	survey->noise = -92;  
+    
 	return 0;
 }
 
@@ -1724,6 +1769,7 @@ void nrc_mac_cancel_hw_scan(struct ieee80211_hw *hw,
 	nrc_cancel_hw_scan(hw, vif);
 }
 
+#ifdef NRC_BUILD_USE_HWSCAN
 static int
 __nrc_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		  struct cfg80211_scan_request *req,
@@ -1774,6 +1820,7 @@ nrc_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return __nrc_mac_hw_scan(hw, vif, req, NULL);
 }
 #endif
+#endif /* NRC_BUILD_USE_HWSCAN */
 
 #ifdef CONFIG_USE_SCAN_TIMEOUT
 static void nrc_mac_scan_timeout(struct work_struct *work)
@@ -1810,7 +1857,7 @@ nrc_mac_set_bitrate_mask(struct ieee80211_hw *hw,
 			mask->control[1].legacy,
 			mask->control[0].ht_mcs[0],
 			mask->control[1].ht_mcs[0]);
-
+#ifndef CONFIG_S1G_CHANNEL
 	if (mask->control[band].ht_mcs[0] == 0xFF)
 		band = NL80211_BAND_5GHZ;
 	mcs_mask = mask->control[band].ht_mcs[0] & 0xFF;
@@ -1828,6 +1875,12 @@ nrc_mac_set_bitrate_mask(struct ieee80211_hw *hw,
 			mcs_mask = mcs_mask>>1;
 		}
 	}
+#else
+    band = NL80211_BAND_S1GHZ;
+    mcs_level = 10;
+    mcs_mask = 0xFF;
+    i = 0;  // mask compiler warning
+#endif
 	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
 	nrc_wim_skb_add_tlv(skb, WIM_TLV_MCS, sizeof(mcs_level), &mcs_level);
 	ret = nrc_xmit_wim_request(nw, skb);
@@ -1842,8 +1895,6 @@ static void nrc_mac_sw_scan(struct ieee80211_hw *hw,
 {
 	struct nrc *nw = hw->priv;
 
-	nrc_mac_dbg("%s", __func__);
-
 	mutex_lock(&nw->state_mtx);
 
 	if (nw->scan_mode == NRC_SCAN_MODE_IDLE) {
@@ -1861,8 +1912,6 @@ static void nrc_mac_sw_scan_complete(struct ieee80211_hw *hw,
 {
 	struct nrc *nw = hw->priv;
 
-	nrc_mac_dbg("%s", __func__);
-
 	mutex_lock(&nw->state_mtx);
 
 	if (nw->scan_mode == NRC_SCAN_MODE_SCANNING) {
@@ -1874,7 +1923,7 @@ static void nrc_mac_sw_scan_complete(struct ieee80211_hw *hw,
  out:
 	mutex_unlock(&nw->state_mtx);
 }
-#endif
+#endif /* NRC_BUILD_USE_HWSCAN */
 
 #ifdef CONFIG_SUPPORT_NEW_FLUSH
 static void nrc_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
@@ -2128,7 +2177,11 @@ static int nrc_mac_roc(struct ieee80211_hw *hw, struct ieee80211_channel *chan,
 #ifdef CONFIG_SUPPORT_CHANNEL_INFO
 	if (!hw->conf.chandef.chan) {
 		chandef.chan = chan;
+#ifndef  CONFIG_S1G_CHANNEL       
 		chandef.width = NL80211_CHAN_WIDTH_20;
+#else     
+        chandef.width = NL80211_CHAN_WIDTH_1;
+#endif
 		cdef = &chandef;
 	} else
 		cdef = &hw->conf.chandef;
@@ -2172,7 +2225,6 @@ static int nrc_mac_cancel_roc(struct ieee80211_hw *hw)
 {
 	struct nrc *nw = hw->priv;
 
-	nrc_mac_dbg("%s", __func__);
 	cancel_delayed_work_sync(&nw->roc_finish);
 
 	return 0;
@@ -2276,12 +2328,38 @@ static int nrc_mac_switch_vif_chanctx(struct ieee80211_hw *hw,
 	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
 	if (!skb)
 		return -EINVAL;
-
+#if !defined(CONFIG_S1G_CHANNEL)
 	nrc_wim_skb_add_tlv(skb,
 			WIM_TLV_CHANNEL,
 			sizeof(new_ctx->def.chan->center_freq),
 			&new_ctx->def.chan->center_freq);
+#else
+	struct wim_s1g_channel_param param;
 
+	param.pr_freq = FREQ_TO_100KHZ(new_ctx->def.chan->center_freq,
+				new_ctx->def.chan->freq_offset);
+	param.op_freq = FREQ_TO_100KHZ(new_ctx->def.chan->center_freq1,
+				new_ctx->def.chan->freq1_offset);
+	
+
+    if(new_ctx->def.chan->width < NL80211_CHAN_WIDTH_1 || new_ctx->def.chan->width > NL80211_CHAN_WIDTH_4) {
+        if(new_ctx->def.chan->freq1_offset == 500)
+            param.width = CH_WIDTH_1;
+        else
+            param.width = CH_WIDTH_2;
+    }
+    else {
+        param.width = get_wim_channel_width(new_ctx->def.chan->width);
+    }
+    
+    param.flags = 0;
+    
+    nrc_mac_dbg("%s: pr_freq(%d), op_freq(%d), width(%d)\n", __func__, param.pr_freq,
+			param.op_freq, param.width);
+    
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_S1G_CHANNEL, sizeof(param),
+			&param);
+#endif
 	nrc_xmit_wim_request(nw, skb);
 
 #ifdef CONFIG_SUPPORT_ITERATE_INTERFACE
@@ -2611,7 +2689,6 @@ static const struct nl80211_vendor_cmd_info nrc_vendor_events[] = {
 	},
 };
 
-
 /**
  * nrc_hw_register - initialize struct ieee80211_hw instance
  */
@@ -2650,12 +2727,10 @@ int nrc_register_hw(struct nrc *nw)
 #ifdef CONFIG_MAC80211_MESH
 		BIT(NL80211_IFTYPE_MESH_POINT) |
 #endif
-#if !defined(CONFIG_S1G_CHANNEL)
 #ifdef CONFIG_SUPPORT_P2P
 		BIT(NL80211_IFTYPE_P2P_CLIENT) | BIT(NL80211_IFTYPE_P2P_GO) |
 		BIT(NL80211_IFTYPE_P2P_DEVICE) |
 #endif
-#endif /* CONFIG_S1G_CHANNEL */
 #if defined(CONFIG_WIRELESS_WDS)
 		BIT(NL80211_IFTYPE_WDS) |
 #endif
@@ -2738,12 +2813,15 @@ int nrc_register_hw(struct nrc *nw)
 		switch (band) {
 #if defined(CONFIG_S1G_CHANNEL)
 		case NL80211_BAND_S1GHZ:
+            memcpy(&sband->s1g_cap, &nrc_s1g_cap,
+			       sizeof(sband->s1g_cap));
+            init_s1g_channels(nrc_channels_s1ghz);
 			sband->channels = nrc_channels_s1ghz;
-			sband->n_channels = ARRAY_SIZE(nrc_channels_s1ghz);
+			sband->n_channels = NUM_S1G_CHAN_US;
 			sband->bitrates = nrc_rates;
 			sband->n_bitrates = ARRAY_SIZE(nrc_rates);
-
-			sband->s1g_cap.s1g_supported = true;
+            sband->band = NL80211_BAND_S1GHZ;
+            sband->ht_cap.ht_supported = false;
 			hw->wiphy->bands[band] = sband;
 			continue;
 			break;
@@ -2814,14 +2892,19 @@ int nrc_register_hw(struct nrc *nw)
 	hw->wiphy->vendor_events = nrc_vendor_events;
 	hw->wiphy->n_vendor_events = ARRAY_SIZE(nrc_vendor_events);
 
+    // NOTE: use wireless-regdb with 802.11ah freqs
 #ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
-	hw->wiphy->regulatory_flags =
+#ifdef CONFIG_CUSTOM_REGDB
+    hw->wiphy->regulatory_flags |=
 		REGULATORY_CUSTOM_REG|WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
-#endif
 
 	wiphy_apply_custom_regulatory(hw->wiphy, &mac80211_regdom);
 	nw->alpha2[0] = '9';
-	nw->alpha2[1] = '9';
+	nw->alpha2[1] = '9';  
+#else
+    hw->wiphy->regulatory_flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+#endif
+#endif
 
 	if (nrc_mac_is_s1g(nw)) {
 		/*this is only for 802.11ah*/
@@ -2882,5 +2965,9 @@ void nrc_unregister_hw(struct nrc *nw)
 
 bool nrc_mac_is_s1g(struct nrc *nw)
 {
+#ifdef CONFIG_S1G_CHANNEL
+    return 1;
+#else
 	return (nw->fwinfo.version != WIM_SYSTEM_VER_11N);
+#endif
 }
diff --git a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-netlink.c b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-netlink.c
index 18b2e9a..5ea9f64 100755
--- a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-netlink.c
+++ b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-netlink.c
@@ -496,6 +496,7 @@ static int halow_set_dut(struct sk_buff *skb, struct genl_info *info)
 	return halow_reply(NL_HALOW_SET_DUT, info, NL_HALOW_RESP_OK);
 
 halow_not_supported:
+	nrc_dbg(NRC_DBG_CAPI, "%s: halow_not_supported", __func__);
 	return halow_reply(NL_HALOW_SET_DUT, info, NL_HALOW_RESP_NOT_SUPP);
 }
 
@@ -1536,7 +1537,6 @@ int nrc_netlink_init(struct nrc *nw)
 
 void nrc_netlink_exit(void)
 {
-	pr_err("%s", __func__);
 	netlink_unregister_notifier(&nl_umac_netlink_notifier);
 	genl_unregister_family(&nrc_nl_fam);
 }
diff --git a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-trx.c b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-trx.c
index 838a87d..66599a7 100755
--- a/package/host/nrc_driver/source/nrc_driver/nrc/nrc-trx.c
+++ b/package/host/nrc_driver/source/nrc_driver/nrc/nrc-trx.c
@@ -271,6 +271,181 @@ static int tx_h_put_iv(struct nrc_trx_data *tx)
 TXH(tx_h_put_iv, NL80211_IFTYPE_ALL);
 
 
+
+#ifdef CONFIG_S1G_CHANNEL
+// NOTE: current firmware puts bogus frequencies into skb header, need to remap for native S1G
+static void nrc_remap_freqs(struct ieee80211_rx_status *status)
+{
+    nrc_mac_dbg("%s: status->freq %d\n",__func__, status->freq);
+    
+    status->freq_offset = 0;
+    
+    switch(status->freq)
+    {
+         case 2417:
+             status->freq = 902; //1
+             status->freq_offset = 1;
+             break;
+         case 2422:
+             status->freq = 903; //3
+             status->freq_offset = 1;
+             break;
+         case 2427:
+             status->freq = 904; //4
+             break;
+         case 2432:
+             status->freq = 904; //5
+             status->freq_offset = 1;
+             break;
+         case 2437:
+             status->freq = 905; //6
+             break;             
+         case 2442:
+             status->freq = 905; //7
+             status->freq_offset = 1;
+             break;
+        case 2447:
+             status->freq = 906; //8
+             break;
+         case 2452:
+             status->freq = 906; //9
+             status->freq_offset = 1;
+             break;
+        case 2457:
+             status->freq = 907; //10
+             break;
+        case 2462:
+             status->freq = 907; //11
+             status->freq_offset = 1;
+             break;
+        case 2467:
+             status->freq = 908; //11
+             break;
+        case 5180:
+             status->freq = 908; //36
+             status->freq_offset = 1;
+             break;
+        case 5765:
+             status->freq = 909; //153
+             break;
+        case 5185:
+             status->freq = 909; //37
+             status->freq_offset = 1;
+             break;
+        case 5810:
+             status->freq = 910; //162
+             break;
+        case 5190:
+             status->freq = 910; //38
+             status->freq_offset = 1;
+             break;
+        case 5770:
+             status->freq = 911; //154
+             break;
+        case 5195:
+             status->freq = 911; //39
+             status->freq_offset = 1;
+             break;
+        case 5200:
+             status->freq = 912; //40
+             status->freq_offset = 1;
+             break;
+        case 5775:
+             status->freq = 913; //155
+             break;
+        case 5205:
+             status->freq = 913; //41
+             status->freq_offset = 1;
+             break;
+        case 5815:
+             status->freq = 914; //163
+             break;
+        case 5210:
+             status->freq = 914; //42
+             status->freq_offset = 1;
+             break;
+        case 5780:
+             status->freq = 915; //156;
+             break;
+        case 5215:
+             status->freq = 915; //43
+             status->freq_offset = 1;
+             break;
+        case 5220:
+             status->freq = 916; //44
+             status->freq_offset = 1;
+             break;
+        case 5785:
+             status->freq = 917; //157
+             break;
+        case 5225:
+             status->freq = 917; //45
+             status->freq_offset = 1;
+             break;
+        case 5820:
+             status->freq = 918; //164
+             break;
+        case 5230:
+             status->freq = 918; //46
+             status->freq_offset = 1;
+             break;
+        case 5790:
+             status->freq = 919; //158
+             break;
+        case 5235:
+             status->freq = 919; //47
+             status->freq_offset = 1;
+             break;
+        case 5240:
+             status->freq = 920; //48
+             status->freq_offset = 1;
+             break;
+        case 5795:
+             status->freq = 921; //159
+             break;
+        case 5745:
+             status->freq = 921; //149
+             status->freq_offset = 1;
+             break;
+        case 5825:
+             status->freq = 922; //165
+             break;
+        case 5750:
+             status->freq = 922; //150
+             status->freq_offset = 1;
+             break;
+        case 5800:
+             status->freq = 923; //160
+             break;
+        case 5755:
+             status->freq = 923; //151
+             status->freq_offset = 1;
+             break;
+        case 5760:
+             status->freq = 924; //152
+             status->freq_offset = 1;
+             break;
+        case 5805:
+             status->freq = 925; //161
+             break;
+        case 5500:
+             status->freq = 925; //100
+             status->freq_offset = 1;
+             break;
+        case 5520:
+             status->freq = 926; //104
+             status->freq_offset = 1;
+             break;
+        case 5540:
+             status->freq = 927; //108
+             status->freq_offset = 1;
+             break;
+     } 
+     
+     nrc_mac_dbg("%s: status->freq %d\n",__func__, status->freq);
+}
+#endif
+
 /* RX */
 
 static void nrc_mac_rx_h_status(struct nrc *nw, struct sk_buff *skb)
@@ -290,6 +465,11 @@ static void nrc_mac_rx_h_status(struct nrc *nw, struct sk_buff *skb)
 	status->band = nw->band; /* I hate this */
 	status->rate_idx = 0;
 
+#ifdef CONFIG_S1G_CHANNEL
+    // firmware puts bogus frequency info into skb header, need to remap
+    nrc_remap_freqs(status);
+#endif
+
 	if (fh->flags.rx.error_mic)
 		status->flag |= RX_FLAG_MMIC_ERROR;
 	if (fh->flags.rx.iv_stripped)
@@ -355,7 +535,7 @@ int nrc_mac_rx(struct nrc *nw, struct sk_buff *skb)
 	}
 
 	nrc_mac_rx_h_status(nw, skb);
-
+    
 	if (nw->promisc) {
 		ret = nrc_mac_s1g_monitor_rx(nw, skb);
 		return ret;
diff --git a/package/host/nrc_driver/source/nrc_driver/nrc/wim.c b/package/host/nrc_driver/source/nrc_driver/nrc/wim.c
index b0f2ffa..1a19320 100755
--- a/package/host/nrc_driver/source/nrc_driver/nrc/wim.c
+++ b/package/host/nrc_driver/source/nrc_driver/nrc/wim.c
@@ -152,6 +152,156 @@ int nrc_wim_change_sta(struct nrc *nw, struct ieee80211_vif *vif,
 	return nrc_xmit_wim_request(nw, skb);
 }
 
+#ifdef NRC_BUILD_USE_HWSCAN
+
+#ifdef CONFIG_S1G_CHANNEL
+#define FREQ_TO_100KHZ(mhz, khz) (mhz * 10 + khz / 100)
+
+ uint16_t   s1g_map_channel(int channel, int offset)
+ {
+     uint16_t freq, s1g_freq;
+     
+     s1g_freq = FREQ_TO_100KHZ(channel, offset);
+
+     switch(s1g_freq)
+     {
+         case 9025:
+             freq = 2417; //1
+             break;
+         case 9035:
+             freq = 2422; //3
+             break;
+         case 9040:
+             freq = 2427; //4
+             break;
+         case 9045:
+             freq = 2432; //5
+             break;
+         case 9050:
+             freq = 2437; //6
+             break;             
+         case 9055:
+             freq = 2442; //7
+             break;
+        case 9060:
+             freq = 2447; //8
+             break;
+         case 9065:
+             freq = 2452; //9
+             break;
+        case 9070:
+             freq = 2457; //10
+             break;
+        case 9075:
+             freq = 2462; //11
+             break;
+        case 9085:
+             freq = 5180; //36
+             break;
+        case 9090:
+             freq = 5765; //153
+             break;
+        default:             
+        case 9095:
+             freq = 5185; //37
+             break;
+        case 9100:
+             freq = 5810; //162
+             break;
+        case 9105:
+             freq = 5190; //38
+             break;
+        case 9110:
+             freq = 5770; //154
+             break;
+        case 9115:
+             freq = 5195; //39
+             break;
+        case 9125:
+             freq = 5200; //40
+             break;
+        case 9130:
+             freq = 5775; //155
+             break;
+        case 9135:
+             freq = 5205; //41
+             break;
+        case 9140:
+             freq = 5815; //163
+             break;
+        case 9145:
+             freq = 5210; //42
+             break;
+        case 9150:
+             freq = 5780; //156;
+             break;
+        case 9155:
+             freq = 5215; //43
+             break;
+        case 9165:
+             freq = 5220; //44
+             break;
+        case 9170:
+             freq = 5785; //157
+             break;
+        case 9175:
+             freq = 5225; //45
+             break;
+        case 9180:
+             freq = 5820; //164
+             break;
+        case 9185:
+             freq = 5230; //46
+             break;
+        case 9190:
+             freq = 5790; //158
+             break;
+        case 9195:
+             freq = 5235; //47
+             break;
+        case 9205:
+             freq = 5240; //48
+             break;
+        case 9210:
+             freq = 5795; //159
+             break;
+        case 9215:
+             freq = 5745; //149
+             break;
+        case 9220:
+             freq = 5825; //165
+             break;
+        case 9225:
+             freq = 5750; //150
+             break;
+        case 9230:
+             freq = 5800; //160
+             break;
+        case 9235:
+             freq = 5755; //151
+             break;
+        case 9245:
+             freq = 5760; //152
+             break;
+        case 9250:
+             freq = 5805; //161
+             break;
+        case 9255:
+             freq = 5500; //100
+             break;
+        case 9265:
+             freq = 5520; //104
+             break;
+        case 9275:
+             freq = 5540; //108
+             break;
+     }
+     
+     return freq;
+     
+ }
+#endif /* CONFIG_S1G_CHANNEL */
+
 int nrc_wim_hw_scan(struct nrc *nw, struct ieee80211_vif *vif,
 		    struct cfg80211_scan_request *req,
 		    struct ieee80211_scan_ies *ies)
@@ -159,11 +309,14 @@ int nrc_wim_hw_scan(struct nrc *nw, struct ieee80211_vif *vif,
 	struct sk_buff *skb;
 	struct wim_scan_param *p;
 	int i, size = tlv_len(sizeof(struct wim_scan_param));
-
+    
 	if (ies) {
 		size += tlv_len(ies->common_ie_len);
 		size += ies->len[NL80211_BAND_2GHZ];
 		size += ies->len[NL80211_BAND_5GHZ];
+#ifdef  CONFIG_S1G_CHANNEL
+        size += ies->len[NL80211_BAND_S1GHZ];
+#endif
 	} else {
 		size += tlv_len(req->ie_len);
 	}
@@ -179,7 +332,13 @@ int nrc_wim_hw_scan(struct nrc *nw, struct ieee80211_vif *vif,
 
 	p->n_channels = req->n_channels;
 	for (i = 0; i < req->n_channels; i++)
+    {
+#ifdef CONFIG_S1G_CHANNEL
+        p->channel[i] = s1g_map_channel(req->channels[i]->center_freq, req->channels[i]->freq_offset);
+#else
 		p->channel[i] = req->channels[i]->center_freq;
+#endif
+    }
 
 	p->n_ssids = req->n_ssids;
 	for (i = 0; i < req->n_ssids; i++) {
@@ -196,6 +355,9 @@ int nrc_wim_hw_scan(struct nrc *nw, struct ieee80211_vif *vif,
 					WIM_TLV_SCAN_PROBE_REQ_IE,
 					ies->common_ie_len +
 					ies->len[NL80211_BAND_2GHZ] +
+#ifdef  CONFIG_S1G_CHANNEL
+					ies->len[NL80211_BAND_S1GHZ] +
+#endif
 					ies->len[NL80211_BAND_5GHZ],
 					NULL);
 
@@ -218,7 +380,7 @@ int nrc_wim_hw_scan(struct nrc *nw, struct ieee80211_vif *vif,
 
 	return nrc_xmit_wim_request(nw, skb);
 }
-
+#endif
 
 static char *ieee80211_cipher_str(u32 cipher)
 {
